"apoc.algo.aStar"	"Runs the A* search algorithm to find the optimal path between two `NODE` values, using the given `RELATIONSHIP` property name for the cost function."	"apoc.algo.aStar(startNode :: NODE, endNode :: NODE, relTypesAndDirections :: STRING, weightPropertyName :: STRING, latPropertyName :: STRING, lonPropertyName :: STRING) :: (path :: PATH, weight :: FLOAT)"
"apoc.algo.aStarConfig"	"Runs the A* search algorithm to find the optimal path between two `NODE` values, using the given `RELATIONSHIP` property name for the cost function.
This procedure looks for weight, latitude and longitude properties in the config."	"apoc.algo.aStarConfig(startNode :: NODE, endNode :: NODE, relTypesAndDirections :: STRING, config :: MAP) :: (path :: PATH, weight :: FLOAT)"
"apoc.algo.allSimplePaths"	"Runs a search algorithm to find all of the simple paths between the given `RELATIONSHIP` values, up to a max depth described by `maxNodes`.
The returned paths will not contain loops."	"apoc.algo.allSimplePaths(startNode :: NODE, endNode :: NODE, relTypesAndDirections :: STRING, maxNodes :: INTEGER) :: (path :: PATH)"
"apoc.algo.cover"	"Returns all `RELATIONSHIP` values connecting the given set of `NODE` values."	"apoc.algo.cover(nodes :: ANY) :: (rel :: RELATIONSHIP)"
"apoc.algo.dijkstra"	"Runs Dijkstra's algorithm using the given `RELATIONSHIP` property as the cost function."	"apoc.algo.dijkstra(startNode :: NODE, endNode :: NODE, relTypesAndDirections :: STRING, weightPropertyName :: STRING, defaultWeight = NaN :: FLOAT, numberOfWantedPaths = 1 :: INTEGER) :: (path :: PATH, weight :: FLOAT)"
"apoc.atomic.add"	"Sets the given property to the sum of itself and the given `INTEGER` or `FLOAT` value.
The procedure then sets the property to the returned sum."	"apoc.atomic.add(container :: ANY, propertyName :: STRING, number :: INTEGER | FLOAT, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)"
"apoc.atomic.concat"	"Sets the given property to the concatenation of itself and the `STRING` value.
The procedure then sets the property to the returned `STRING`."	"apoc.atomic.concat(container :: ANY, propertyName :: STRING, string :: STRING, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)"
"apoc.atomic.insert"	"Inserts a value at position into the `LIST<ANY>` value of a property.
The procedure then sets the result back on the property."	"apoc.atomic.insert(container :: ANY, propertyName :: STRING, position :: INTEGER, value :: ANY, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)"
"apoc.atomic.remove"	"Removes the element at position from the `LIST<ANY>` value of a property.
The procedure then sets the property to the resulting `LIST<ANY>` value."	"apoc.atomic.remove(container :: ANY, propertyName :: STRING, position :: INTEGER, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)"
"apoc.atomic.subtract"	"Sets the property of a value to itself minus the given `INTEGER` or `FLOAT` value.
The procedure then sets the property to the returned sum."	"apoc.atomic.subtract(container :: ANY, propertyName :: STRING, number :: INTEGER | FLOAT, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)"
"apoc.atomic.update"	"Updates the value of a property with a Cypher operation."	"apoc.atomic.update(container :: ANY, propertyName :: STRING, operation :: STRING, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)"
"apoc.case"	"For each pair of conditional and read-only queries in the given `LIST<ANY>`, this procedure will run the first query for which the conditional is evaluated to true. If none of the conditionals are true, the `ELSE` query will run instead."	"apoc.case(conditionals :: LIST<ANY>, elseQuery =  :: STRING, params = {} :: MAP) :: (value :: MAP)"
"apoc.coll.elements"	"Deconstructs a `LIST<ANY>` into identifiers indicating their specific type."	"apoc.coll.elements(coll :: LIST<ANY>, limit = -1 :: INTEGER, offset = 0 :: INTEGER) :: (_1 :: ANY, _2 :: ANY, _3 :: ANY, _4 :: ANY, _5 :: ANY, _6 :: ANY, _7 :: ANY, _8 :: ANY, _9 :: ANY, _10 :: ANY, _1s :: STRING, _2s :: STRING, _3s :: STRING, _4s :: STRING, _5s :: STRING, _6s :: STRING, _7s :: STRING, _8s :: STRING, _9s :: STRING, _10s :: STRING, _1i :: INTEGER, _2i :: INTEGER, _3i :: INTEGER, _4i :: INTEGER, _5i :: INTEGER, _6i :: INTEGER, _7i :: INTEGER, _8i :: INTEGER, _9i :: INTEGER, _10i :: INTEGER, _1f :: FLOAT, _2f :: FLOAT, _3f :: FLOAT, _4f :: FLOAT, _5f :: FLOAT, _6f :: FLOAT, _7f :: FLOAT, _8f :: FLOAT, _9f :: FLOAT, _10f :: FLOAT, _1b :: BOOLEAN, _2b :: BOOLEAN, _3b :: BOOLEAN, _4b :: BOOLEAN, _5b :: BOOLEAN, _6b :: BOOLEAN, _7b :: BOOLEAN, _8b :: BOOLEAN, _9b :: BOOLEAN, _10b :: BOOLEAN, _1l :: LIST<ANY>, _2l :: LIST<ANY>, _3l :: LIST<ANY>, _4l :: LIST<ANY>, _5l :: LIST<ANY>, _6l :: LIST<ANY>, _7l :: LIST<ANY>, _8l :: LIST<ANY>, _9l :: LIST<ANY>, _10l :: LIST<ANY>, _1m :: MAP, _2m :: MAP, _3m :: MAP, _4m :: MAP, _5m :: MAP, _6m :: MAP, _7m :: MAP, _8m :: MAP, _9m :: MAP, _10m :: MAP, _1n :: NODE, _2n :: NODE, _3n :: NODE, _4n :: NODE, _5n :: NODE, _6n :: NODE, _7n :: NODE, _8n :: NODE, _9n :: NODE, _10n :: NODE, _1r :: RELATIONSHIP, _2r :: RELATIONSHIP, _3r :: RELATIONSHIP, _4r :: RELATIONSHIP, _5r :: RELATIONSHIP, _6r :: RELATIONSHIP, _7r :: RELATIONSHIP, _8r :: RELATIONSHIP, _9r :: RELATIONSHIP, _10r :: RELATIONSHIP, _1p :: PATH, _2p :: PATH, _3p :: PATH, _4p :: PATH, _5p :: PATH, _6p :: PATH, _7p :: PATH, _8p :: PATH, _9p :: PATH, _10p :: PATH, elements :: INTEGER)"
"apoc.coll.pairWithOffset"	"Returns a `LIST<ANY>` of pairs defined by the offset."	"apoc.coll.pairWithOffset(coll :: LIST<ANY>, offset :: INTEGER) :: (value :: LIST<ANY>)"
"apoc.coll.partition"	"Partitions the original `LIST<ANY>` into a new `LIST<ANY>` of the given batch size.
The final `LIST<ANY>` may be smaller than the given batch size."	"apoc.coll.partition(coll :: LIST<ANY>, batchSize :: INTEGER) :: (value :: LIST<ANY>)"
"apoc.coll.split"	"Splits a collection by the given value.
The value itself will not be part of the resulting `LIST<ANY>` values."	"apoc.coll.split(coll :: LIST<ANY>, value :: ANY) :: (value :: LIST<ANY>)"
"apoc.coll.zipToRows"	"Returns the two `LIST<ANY>` values zipped together, with one row per zipped pair."	"apoc.coll.zipToRows(list1 :: LIST<ANY>, list2 :: LIST<ANY>) :: (value :: LIST<ANY>)"
"apoc.convert.setJsonProperty"	"Serializes the given JSON object and sets it as a property on the given `NODE`."	"apoc.convert.setJsonProperty(node :: NODE, key :: STRING, value :: ANY)"
"apoc.convert.toTree"	"Returns a stream of `MAP` values, representing the given `PATH` values as a tree with at least one root."	"apoc.convert.toTree(paths :: LIST<PATH>, lowerCaseRels = true :: BOOLEAN, config = {} :: MAP) :: (value :: MAP)"
"apoc.create.addLabels"	"Adds the given labels to the given `NODE` values."	"apoc.create.addLabels(nodes :: ANY, labels :: LIST<STRING>) :: (node :: NODE)"
"apoc.create.clonePathToVirtual"	"Takes the given `PATH` and returns a virtual representation of it."	"apoc.create.clonePathToVirtual(path :: PATH) :: (path :: PATH)"
"apoc.create.clonePathsToVirtual"	"Takes the given `LIST<PATH>` and returns a virtual representation of them."	"apoc.create.clonePathsToVirtual(paths :: LIST<PATH>) :: (path :: PATH)"
"apoc.create.node"	"Creates a `NODE` with the given dynamic labels."	"apoc.create.node(labels :: LIST<STRING>, props :: MAP) :: (node :: NODE)"
"apoc.create.nodes"	"Creates `NODE` values with the given dynamic labels."	"apoc.create.nodes(labels :: LIST<STRING>, props :: LIST<MAP>) :: (node :: NODE)"
"apoc.create.relationship"	"Creates a `RELATIONSHIP` with the given dynamic relationship type."	"apoc.create.relationship(from :: NODE, relType :: STRING, props :: MAP, to :: NODE) :: (rel :: RELATIONSHIP)"
"apoc.create.removeLabels"	"Removes the given labels from the given `NODE` values."	"apoc.create.removeLabels(nodes :: ANY, labels :: LIST<STRING>) :: (node :: NODE)"
"apoc.create.removeProperties"	"Removes the given properties from the given `NODE` values."	"apoc.create.removeProperties(nodes :: ANY, keys :: LIST<STRING>) :: (node :: NODE)"
"apoc.create.removeRelProperties"	"Removes the given properties from the given `RELATIONSHIP` values."	"apoc.create.removeRelProperties(rels :: ANY, keys :: LIST<STRING>) :: (rel :: RELATIONSHIP)"
"apoc.create.setLabels"	"Sets the given labels to the given `NODE` values. Non-matching labels are removed from the nodes."	"apoc.create.setLabels(nodes :: ANY, labels :: LIST<STRING>) :: (node :: NODE)"
"apoc.create.setProperties"	"Sets the given properties to the given `NODE` values."	"apoc.create.setProperties(nodes :: ANY, keys :: LIST<STRING>, values :: LIST<ANY>) :: (node :: NODE)"
"apoc.create.setProperty"	"Sets the given property to the given `NODE` values."	"apoc.create.setProperty(nodes :: ANY, key :: STRING, value :: ANY) :: (node :: NODE)"
"apoc.create.setRelProperties"	"Sets the given properties on the `RELATIONSHIP` values."	"apoc.create.setRelProperties(rels :: ANY, keys :: LIST<STRING>, values :: LIST<ANY>) :: (rel :: RELATIONSHIP)"
"apoc.create.setRelProperty"	"Sets the given property on the `RELATIONSHIP` values."	"apoc.create.setRelProperty(rels :: ANY, key :: STRING, value :: ANY) :: (rel :: RELATIONSHIP)"
"apoc.create.uuids"	"Returns a stream of UUIDs."	"apoc.create.uuids(count :: INTEGER) :: (row :: INTEGER, uuid :: STRING)"
"apoc.create.vNode"	"Returns a virtual `NODE`."	"apoc.create.vNode(labels :: LIST<STRING>, props :: MAP) :: (node :: NODE)"
"apoc.create.vNodes"	"Returns virtual `NODE` values."	"apoc.create.vNodes(labels :: LIST<STRING>, props :: LIST<MAP>) :: (node :: NODE)"
"apoc.create.vRelationship"	"Returns a virtual `RELATIONSHIP`."	"apoc.create.vRelationship(from :: NODE, relType :: STRING, props :: MAP, to :: NODE) :: (rel :: RELATIONSHIP)"
"apoc.create.virtualPath"	"Returns a virtual `PATH`."	"apoc.create.virtualPath(labelsN :: LIST<STRING>, n :: MAP, arelType :: STRING, props :: MAP, labelsM :: LIST<STRING>, m :: MAP) :: (from :: NODE, rel :: RELATIONSHIP, to :: NODE)"
"apoc.cypher.doIt"	"Runs a dynamically constructed statement with the given parameters. This procedure allows for both read and write statements."	"apoc.cypher.doIt(statement :: STRING, params :: MAP) :: (value :: MAP)"
"apoc.cypher.run"	"Runs a dynamically constructed read-only statement with the given parameters."	"apoc.cypher.run(statement :: STRING, params :: MAP) :: (value :: MAP)"
"apoc.cypher.runMany"	"Runs each semicolon separated statement and returns a summary of the statement outcomes."	"apoc.cypher.runMany(statement :: STRING, params :: MAP, config = {} :: MAP) :: (row :: INTEGER, result :: MAP)"
"apoc.cypher.runManyReadOnly"	"Runs each semicolon separated read-only statement and returns a summary of the statement outcomes."	"apoc.cypher.runManyReadOnly(statement :: STRING, params :: MAP, config = {} :: MAP) :: (row :: INTEGER, result :: MAP)"
"apoc.cypher.runSchema"	"Runs the given query schema statement with the given parameters."	"apoc.cypher.runSchema(statement :: STRING, params :: MAP) :: (value :: MAP)"
"apoc.cypher.runTimeboxed"	"Terminates a Cypher statement if it has not finished before the set timeout (ms)."	"apoc.cypher.runTimeboxed(statement :: STRING, params :: MAP, timeout :: INTEGER) :: (value :: MAP)"
"apoc.cypher.runWrite"	"Alias for `apoc.cypher.doIt`."	"apoc.cypher.runWrite(statement :: STRING, params :: MAP) :: (value :: MAP)"
"apoc.do.case"	"For each pair of conditional queries in the given `LIST<ANY>`, this procedure will run the first query for which the conditional is evaluated to true.
If none of the conditionals are true, the `ELSE` query will run instead."	"apoc.do.case(conditionals :: LIST<ANY>, elseQuery =  :: STRING, params = {} :: MAP) :: (value :: MAP)"
"apoc.do.when"	"Runs the given read/write `ifQuery` if the conditional has evaluated to true, otherwise the `elseQuery` will run."	"apoc.do.when(condition :: BOOLEAN, ifQuery :: STRING, elseQuery :: STRING, params = {} :: MAP) :: (value :: MAP)"
"apoc.example.movies"	"Seeds the database with the Neo4j movie dataset."	"apoc.example.movies() :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.arrow.all"	"Exports the full database as an arrow file."	"apoc.export.arrow.all(file :: STRING, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.arrow.graph"	"Exports the given graph as an arrow file."	"apoc.export.arrow.graph(file :: STRING, graph :: ANY, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.arrow.query"	"Exports the results from the given Cypher query as an arrow file."	"apoc.export.arrow.query(file :: STRING, query :: STRING, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.arrow.stream.all"	"Exports the full database as an arrow byte array."	"apoc.export.arrow.stream.all(config = {} :: MAP) :: (value :: BYTEARRAY)"
"apoc.export.arrow.stream.graph"	"Exports the given graph as an arrow byte array."	"apoc.export.arrow.stream.graph(graph :: ANY, config = {} :: MAP) :: (value :: BYTEARRAY)"
"apoc.export.arrow.stream.query"	"Exports the given Cypher query as an arrow byte array."	"apoc.export.arrow.stream.query(query :: STRING, config = {} :: MAP) :: (value :: BYTEARRAY)"
"apoc.export.csv.all"	"Exports the full database to the provided CSV file."	"apoc.export.csv.all(file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.csv.data"	"Exports the given `NODE` and `RELATIONSHIP` values to the provided CSV file."	"apoc.export.csv.data(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.csv.graph"	"Exports the given graph to the provided CSV file."	"apoc.export.csv.graph(graph :: MAP, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.csv.query"	"Exports the results from running the given Cypher query to the provided CSV file."	"apoc.export.csv.query(query :: STRING, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.cypher.all"	"Exports the full database (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell)."	"apoc.export.cypher.all(file =  :: STRING, config = {} :: MAP) :: (file :: STRING, batches :: INTEGER, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, cypherStatements :: ANY, nodeStatements :: ANY, relationshipStatements :: ANY, schemaStatements :: ANY, cleanupStatements :: ANY)"
"apoc.export.cypher.data"	"Exports the given `NODE` and `RELATIONSHIP` values (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell)."	"apoc.export.cypher.data(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>, file =  :: STRING, config = {} :: MAP) :: (file :: STRING, batches :: INTEGER, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, cypherStatements :: ANY, nodeStatements :: ANY, relationshipStatements :: ANY, schemaStatements :: ANY, cleanupStatements :: ANY)"
"apoc.export.cypher.graph"	"Exports the given graph (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell)."	"apoc.export.cypher.graph(graph :: MAP, file :: STRING, config = {} :: MAP) :: (file :: STRING, batches :: INTEGER, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, cypherStatements :: ANY, nodeStatements :: ANY, relationshipStatements :: ANY, schemaStatements :: ANY, cleanupStatements :: ANY)"
"apoc.export.cypher.query"	"Exports the `NODE` and `RELATIONSHIP` values from the given Cypher query (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell)."	"apoc.export.cypher.query(statement :: STRING, file =  :: STRING, config = {} :: MAP) :: (file :: STRING, batches :: INTEGER, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, cypherStatements :: ANY, nodeStatements :: ANY, relationshipStatements :: ANY, schemaStatements :: ANY, cleanupStatements :: ANY)"
"apoc.export.cypher.schema"	"Exports all schema indexes and constraints to Cypher statements."	"apoc.export.cypher.schema(file =  :: STRING, config = {} :: MAP) :: (file :: STRING, batches :: INTEGER, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, cypherStatements :: ANY, nodeStatements :: ANY, relationshipStatements :: ANY, schemaStatements :: ANY, cleanupStatements :: ANY)"
"apoc.export.graphml.all"	"Exports the full database to the provided GraphML file."	"apoc.export.graphml.all(file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.graphml.data"	"Exports the given `NODE` and `RELATIONSHIP` values to the provided GraphML file."	"apoc.export.graphml.data(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.graphml.graph"	"Exports the given graph to the provided GraphML file."	"apoc.export.graphml.graph(graph :: MAP, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.graphml.query"	"Exports the given `NODE` and `RELATIONSHIP` values from the Cypher statement to the provided GraphML file."	"apoc.export.graphml.query(statement :: STRING, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.json.all"	"Exports the full database to the provided JSON file."	"apoc.export.json.all(file :: STRING, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.json.data"	"Exports the given `NODE` and `RELATIONSHIP` values to the provided JSON file."	"apoc.export.json.data(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>, file :: STRING, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.json.graph"	"Exports the given graph to the provided JSON file."	"apoc.export.json.graph(graph :: MAP, file :: STRING, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.export.json.query"	"Exports the results from the Cypher statement to the provided JSON file."	"apoc.export.json.query(statement :: STRING, file :: STRING, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.graph.from"	"Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the given data."	"apoc.graph.from(data :: ANY, name :: STRING, props :: MAP) :: (graph :: MAP)"
"apoc.graph.fromCypher"	"Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the data returned by the given Cypher statement."	"apoc.graph.fromCypher(statement :: STRING, params :: MAP, name :: STRING, props :: MAP) :: (graph :: MAP)"
"apoc.graph.fromDB"	"Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the data returned by the given database."	"apoc.graph.fromDB(name :: STRING, props :: MAP) :: (graph :: MAP)"
"apoc.graph.fromData"	"Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the given data."	"apoc.graph.fromData(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>, name :: STRING, props :: MAP) :: (graph :: MAP)"
"apoc.graph.fromDocument"	"Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the data returned by the given JSON file."	"apoc.graph.fromDocument(json :: ANY, config = {} :: MAP) :: (graph :: MAP)"
"apoc.graph.fromPath"	"Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the data returned by the given `PATH`."	"apoc.graph.fromPath(path :: PATH, name :: STRING, props :: MAP) :: (graph :: MAP)"
"apoc.graph.fromPaths"	"Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the data returned by the given `PATH` values."	"apoc.graph.fromPaths(paths :: LIST<PATH>, name :: STRING, props :: MAP) :: (graph :: MAP)"
"apoc.graph.validateDocument"	"Validates the JSON file and returns the result of the validation."	"apoc.graph.validateDocument(json :: ANY, config = {} :: MAP) :: (row :: MAP)"
"apoc.help"	"Returns descriptions of the available APOC procedures and functions. If a keyword is provided, it will return only those procedures and functions that have the keyword in their name."	"apoc.help(proc :: STRING) :: (type :: STRING, name :: STRING, text :: STRING, signature :: STRING, roles :: LIST<STRING>, writes :: BOOLEAN, core :: BOOLEAN, isDeprecated :: BOOLEAN)"
"apoc.import.csv"	"Imports `NODE` and `RELATIONSHIP` values with the given labels and types from the provided CSV file."	"apoc.import.csv(nodes :: LIST<MAP>, rels :: LIST<MAP>, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.import.graphml"	"Imports a graph from the provided GraphML file."	"apoc.import.graphml(urlOrBinaryFile :: ANY, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.import.json"	"Imports a graph from the provided JSON file."	"apoc.import.json(urlOrBinaryFile :: ANY, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)"
"apoc.import.xml"	"Imports a graph from the provided XML file."	"apoc.import.xml(urlOrBinary :: ANY, config = {} :: MAP) :: (node :: NODE)"
"apoc.load.arrow"	"Imports `NODE` and `RELATIONSHIP` values from the provided arrow file."	"apoc.load.arrow(file :: STRING, config = {} :: MAP) :: (value :: MAP)"
"apoc.load.arrow.stream"	"Imports `NODE` and `RELATIONSHIP` values from the provided arrow byte array."	"apoc.load.arrow.stream(source :: BYTEARRAY, config = {} :: MAP) :: (value :: MAP)"
"apoc.load.json"	"Imports JSON file as a stream of values if the given JSON file is a `LIST<ANY>`.
If the given JSON file is a `MAP`, this procedure imports a single value instead."	"apoc.load.json(urlOrKeyOrBinary :: ANY, path =  :: STRING, config = {} :: MAP) :: (value :: MAP)"
"apoc.load.jsonArray"	"Loads array from a JSON URL (e.g. web-API) to then import the given JSON file as a stream of values."	"apoc.load.jsonArray(url :: STRING, path =  :: STRING, config = {} :: MAP) :: (value :: ANY)"
"apoc.load.jsonParams"	"Loads parameters from a JSON URL (e.g. web-API) as a stream of values if the given JSON file is a `LIST<ANY>`.
If the given JSON file is a `MAP`, this procedure imports a single value instead."	"apoc.load.jsonParams(urlOrKeyOrBinary :: ANY, headers :: MAP, payload :: STRING, path =  :: STRING, config = {} :: MAP) :: (value :: MAP)"
"apoc.load.xml"	"Loads a single nested `MAP` from an XML URL (e.g. web-API)."	"apoc.load.xml(urlOrBinary :: ANY, path = / :: STRING, config = {} :: MAP, simple = false :: BOOLEAN) :: (value :: MAP)"
"apoc.lock.all"	"Acquires a write lock on the given `NODE` and `RELATIONSHIP` values."	"apoc.lock.all(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>)"
"apoc.lock.nodes"	"Acquires a write lock on the given `NODE` values."	"apoc.lock.nodes(nodes :: LIST<NODE>)"
"apoc.lock.read.nodes"	"Acquires a read lock on the given `NODE` values."	"apoc.lock.read.nodes(nodes :: LIST<NODE>)"
"apoc.lock.read.rels"	"Acquires a read lock on the given `RELATIONSHIP` values."	"apoc.lock.read.rels(rels :: LIST<RELATIONSHIP>)"
"apoc.lock.rels"	"Acquires a write lock on the given `RELATIONSHIP` values."	"apoc.lock.rels(rels :: LIST<RELATIONSHIP>)"
"apoc.log.stream"	"Returns the file contents from the given log, optionally returning only the last n lines.
This procedure requires users to have an admin role."	"apoc.log.stream(path :: STRING, config = {} :: MAP) :: (lineNo :: INTEGER, line :: STRING, path :: STRING)"
"apoc.math.regr"	"Returns the coefficient of determination (R-squared) for the values of propertyY and propertyX in the given label."	"apoc.math.regr(label :: STRING, propertyY :: STRING, propertyX :: STRING) :: (r2 :: FLOAT, avgX :: FLOAT, avgY :: FLOAT, slope :: FLOAT)"
"apoc.merge.node"	"Merges the given `NODE` values with the given dynamic labels."	"apoc.merge.node(labels :: LIST<STRING>, identProps :: MAP, onCreateProps = {} :: MAP, onMatchProps = {} :: MAP) :: (node :: NODE)"
"apoc.merge.node.eager"	"Merges the given `NODE` values with the given dynamic labels eagerly."	"apoc.merge.node.eager(labels :: LIST<STRING>, identProps :: MAP, onCreateProps = {} :: MAP, onMatchProps = {} :: MAP) :: (node :: NODE)"
"apoc.merge.nodeWithStats"	"Merges the given `NODE` values with the given dynamic labels. Provides queryStatistics in the result."	"apoc.merge.nodeWithStats(labels :: LIST<STRING>, identProps :: MAP, onCreateProps = {} :: MAP, onMatchProps = {} :: MAP) :: (stats :: MAP, node :: NODE)"
"apoc.merge.nodeWithStats.eager"	"Merges the given `NODE` values with the given dynamic labels eagerly. Provides queryStatistics in the result."	"apoc.merge.nodeWithStats.eager(labels :: LIST<STRING>, identProps :: MAP, onCreateProps = {} :: MAP, onMatchProps = {} :: MAP) :: (stats :: MAP, node :: NODE)"
"apoc.merge.relationship"	"Merges the given `RELATIONSHIP` values with the given dynamic types/properties."	"apoc.merge.relationship(startNode :: NODE, relType :: STRING, identProps :: MAP, onCreateProps :: MAP, endNode :: NODE, onMatchProps = {} :: MAP) :: (rel :: RELATIONSHIP)"
"apoc.merge.relationship.eager"	"Merges the given `RELATIONSHIP` values with the given dynamic types/properties eagerly."	"apoc.merge.relationship.eager(startNode :: NODE, relType :: STRING, identProps :: MAP, onCreateProps :: MAP, endNode :: NODE, onMatchProps = {} :: MAP) :: (rel :: RELATIONSHIP)"
"apoc.merge.relationshipWithStats"	"Merges the given `RELATIONSHIP` values with the given dynamic types/properties. Provides queryStatistics in the result."	"apoc.merge.relationshipWithStats(startNode :: NODE, relType :: STRING, identProps :: MAP, onCreateProps :: MAP, endNode :: NODE, onMatchProps = {} :: MAP) :: (stats :: MAP, rel :: RELATIONSHIP)"
"apoc.merge.relationshipWithStats.eager"	"Merges the given `RELATIONSHIP` values with the given dynamic types/properties eagerly. Provides queryStatistics in the result."	"apoc.merge.relationshipWithStats.eager(startNode :: NODE, relType :: STRING, identProps :: MAP, onCreateProps :: MAP, endNode :: NODE, onMatchProps = {} :: MAP) :: (stats :: MAP, rel :: RELATIONSHIP)"
"apoc.meta.data"	"apoc.meta.data is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.meta.data(config = {} :: MAP) :: (label :: STRING, property :: STRING, count :: INTEGER, unique :: BOOLEAN, index :: BOOLEAN, existence :: BOOLEAN, type :: STRING, array :: BOOLEAN, sample :: LIST<ANY>, left :: INTEGER, right :: INTEGER, other :: LIST<STRING>, otherLabels :: LIST<STRING>, elementType :: STRING)"
"apoc.meta.data.of"	"apoc.meta.data.of is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.meta.data.of(graph :: ANY, config = {} :: MAP) :: (label :: STRING, property :: STRING, count :: INTEGER, unique :: BOOLEAN, index :: BOOLEAN, existence :: BOOLEAN, type :: STRING, array :: BOOLEAN, sample :: LIST<ANY>, left :: INTEGER, right :: INTEGER, other :: LIST<STRING>, otherLabels :: LIST<STRING>, elementType :: STRING)"
"apoc.meta.graph"	"apoc.meta.graph is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.meta.graph(config = {} :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)"
"apoc.meta.graph.of"	"apoc.meta.graph.of is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.meta.graph.of(graph = {} :: ANY, config = {} :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)"
"apoc.meta.graphSample"	"apoc.meta.graphSample is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.meta.graphSample(config = {} :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)"
"apoc.meta.nodeTypeProperties"	"apoc.meta.nodeTypeProperties is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.meta.nodeTypeProperties(config = {} :: MAP) :: (nodeType :: STRING, nodeLabels :: LIST<STRING>, propertyName :: STRING, propertyTypes :: LIST<STRING>, mandatory :: BOOLEAN, propertyObservations :: INTEGER, totalObservations :: INTEGER)"
"apoc.meta.relTypeProperties"	"apoc.meta.relTypeProperties is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.meta.relTypeProperties(config = {} :: MAP) :: (relType :: STRING, sourceNodeLabels :: LIST<STRING>, targetNodeLabels :: LIST<STRING>, propertyName :: STRING, propertyTypes :: LIST<STRING>, mandatory :: BOOLEAN, propertyObservations :: INTEGER, totalObservations :: INTEGER)"
"apoc.meta.schema"	"apoc.meta.schema is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.meta.schema(config = {} :: MAP) :: (value :: MAP)"
"apoc.meta.stats"	"apoc.meta.stats is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.meta.stats() :: (labelCount :: INTEGER, relTypeCount :: INTEGER, propertyKeyCount :: INTEGER, nodeCount :: INTEGER, relCount :: INTEGER, labels :: MAP, relTypes :: MAP, relTypesCount :: MAP, stats :: MAP)"
"apoc.meta.subGraph"	"apoc.meta.subGraph is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.meta.subGraph(config :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)"
"apoc.neighbors.athop"	"Returns all `NODE` values connected by the given `RELATIONSHIP` types at the specified distance."	"apoc.neighbors.athop(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (node :: NODE)"
"apoc.neighbors.athop.count"	"Returns the count of all `NODE` values connected by the given `RELATIONSHIP` types at the specified distance."	"apoc.neighbors.athop.count(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (value :: INTEGER)"
"apoc.neighbors.byhop"	"Returns all `NODE` values connected by the given `RELATIONSHIP` types within the specified distance. Returns `LIST<NODE>` values, where each `PATH` of `NODE` values represents one row of the `LIST<NODE>` values."	"apoc.neighbors.byhop(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (nodes :: LIST<NODE>)"
"apoc.neighbors.byhop.count"	"Returns the count of all `NODE` values connected by the given `RELATIONSHIP` types within the specified distance."	"apoc.neighbors.byhop.count(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (value :: LIST<ANY>)"
"apoc.neighbors.tohop"	"Returns all `NODE` values connected by the given `RELATIONSHIP` types within the specified distance.
`NODE` values are returned individually for each row."	"apoc.neighbors.tohop(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (node :: NODE)"
"apoc.neighbors.tohop.count"	"Returns the count of all `NODE` values connected by the given `RELATIONSHIP` values in the pattern within the specified distance."	"apoc.neighbors.tohop.count(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (value :: INTEGER)"
"apoc.nodes.collapse"	"apoc.nodes.collapse is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.nodes.collapse(nodes :: LIST<NODE>, config = {} :: MAP) :: (from :: NODE, rel :: RELATIONSHIP, to :: NODE)"
"apoc.nodes.cycles"	"apoc.nodes.cycles is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.nodes.cycles(nodes :: LIST<NODE>, config = {} :: MAP) :: (path :: PATH)"
"apoc.nodes.delete"	"apoc.nodes.delete is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.nodes.delete(nodes :: ANY, batchSize :: INTEGER) :: (value :: INTEGER)"
"apoc.nodes.get"	"apoc.nodes.get is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.nodes.get(nodes :: ANY) :: (node :: NODE)"
"apoc.nodes.group"	"Allows for the aggregation of `NODE` values based on the given properties.
This procedure returns virtual `NODE` values."	"apoc.nodes.group(labels :: LIST<STRING>, groupByProperties :: LIST<STRING>, aggregations = [{*=count}, {*=count}] :: LIST<MAP>, config = {} :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>, node :: NODE, relationship :: RELATIONSHIP)"
"apoc.nodes.link"	"apoc.nodes.link is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.nodes.link(nodes :: LIST<NODE>, type :: STRING, config = {} :: MAP)"
"apoc.nodes.rels"	"apoc.nodes.rels is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.nodes.rels(rels :: ANY) :: (rel :: RELATIONSHIP)"
"apoc.path.expand"	"Returns `PATH` values expanded from the start `NODE` following the given `RELATIONSHIP` types from min-depth to max-depth."	"apoc.path.expand(startNode :: ANY, relFilter :: STRING, labelFilter :: STRING, minDepth :: INTEGER, maxDepth :: INTEGER) :: (path :: PATH)"
"apoc.path.expandConfig"	"Returns `PATH` values expanded from the start `NODE` with the given `RELATIONSHIP` types from min-depth to max-depth."	"apoc.path.expandConfig(startNode :: ANY, config :: MAP) :: (path :: PATH)"
"apoc.path.spanningTree"	"Returns spanning tree `PATH` values expanded from the start `NODE` following the given `RELATIONSHIP` types to max-depth."	"apoc.path.spanningTree(startNode :: ANY, config :: MAP) :: (path :: PATH)"
"apoc.path.subgraphAll"	"Returns the sub-graph reachable from the start `NODE` following the given `RELATIONSHIP` types to max-depth."	"apoc.path.subgraphAll(startNode :: ANY, config :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)"
"apoc.path.subgraphNodes"	"Returns the `NODE` values in the sub-graph reachable from the start `NODE` following the given `RELATIONSHIP` types to max-depth."	"apoc.path.subgraphNodes(startNode :: ANY, config :: MAP) :: (node :: NODE)"
"apoc.paths.toJsonTree"	"Creates a stream of nested documents representing the graph as a tree by traversing outgoing relationships."	"apoc.paths.toJsonTree(paths :: LIST<PATH>, lowerCaseRels = true :: BOOLEAN, config = {} :: MAP) :: (value :: MAP)"
"apoc.periodic.cancel"	"Cancels the given background job."	"apoc.periodic.cancel(name :: STRING) :: (name :: STRING, delay :: INTEGER, rate :: INTEGER, done :: BOOLEAN, cancelled :: BOOLEAN)"
"apoc.periodic.commit"	"Runs the given statement in separate batched transactions."	"apoc.periodic.commit(statement :: STRING, params = {} :: MAP) :: (updates :: INTEGER, executions :: INTEGER, runtime :: INTEGER, batches :: INTEGER, failedBatches :: INTEGER, batchErrors :: MAP, failedCommits :: INTEGER, commitErrors :: MAP, wasTerminated :: BOOLEAN)"
"apoc.periodic.countdown"	"Runs a repeatedly called background statement until it returns 0."	"apoc.periodic.countdown(name :: STRING, statement :: STRING, delay :: INTEGER) :: (name :: STRING, delay :: INTEGER, rate :: INTEGER, done :: BOOLEAN, cancelled :: BOOLEAN)"
"apoc.periodic.iterate"	"Runs the second statement for each item returned by the first statement.
This procedure returns the number of batches and the total number of processed rows."	"apoc.periodic.iterate(cypherIterate :: STRING, cypherAction :: STRING, config :: MAP) :: (batches :: INTEGER, total :: INTEGER, timeTaken :: INTEGER, committedOperations :: INTEGER, failedOperations :: INTEGER, failedBatches :: INTEGER, retries :: INTEGER, errorMessages :: MAP, batch :: MAP, operations :: MAP, wasTerminated :: BOOLEAN, failedParams :: MAP, updateStatistics :: MAP)"
"apoc.periodic.list"	"Returns a `LIST<ANY>` of all background jobs."	"apoc.periodic.list() :: (name :: STRING, delay :: INTEGER, rate :: INTEGER, done :: BOOLEAN, cancelled :: BOOLEAN)"
"apoc.periodic.repeat"	"Runs a repeatedly called background job.
To stop this procedure, use `apoc.periodic.cancel`."	"apoc.periodic.repeat(name :: STRING, statement :: STRING, rate :: INTEGER, config = {} :: MAP) :: (name :: STRING, delay :: INTEGER, rate :: INTEGER, done :: BOOLEAN, cancelled :: BOOLEAN)"
"apoc.periodic.submit"	"Creates a background job which runs the given Cypher statement once."	"apoc.periodic.submit(name :: STRING, statement :: STRING, params = {} :: MAP) :: (name :: STRING, delay :: INTEGER, rate :: INTEGER, done :: BOOLEAN, cancelled :: BOOLEAN)"
"apoc.periodic.truncate"	"Removes all entities (and optionally indexes and constraints) from the database using the `apoc.periodic.iterate` procedure."	"apoc.periodic.truncate(config = {} :: MAP)"
"apoc.refactor.categorize"	"Creates new category `NODE` values from `NODE` values in the graph with the specified `sourceKey` as one of its property keys.
The new category `NODE` values are then connected to the original `NODE` values with a `RELATIONSHIP` of the given type."	"apoc.refactor.categorize(sourceKey :: STRING, type :: STRING, outgoing :: BOOLEAN, label :: STRING, targetKey :: STRING, copiedKeys :: LIST<STRING>, batchSize :: INTEGER)"
"apoc.refactor.cloneNodes"	"Clones the given `NODE` values with their labels and properties.
It is possible to skip any `NODE` properties using skipProperties (note: this only skips properties on `NODE` values and not their `RELATIONSHIP` values)."	"apoc.refactor.cloneNodes(nodes :: LIST<NODE>, withRelationships = false :: BOOLEAN, skipProperties = [] :: LIST<STRING>) :: (input :: INTEGER, output :: NODE, error :: STRING)"
"apoc.refactor.cloneSubgraph"	"Clones the given `NODE` values with their labels and properties (optionally skipping any properties in the `skipProperties` `LIST<STRING>` via the config `MAP`), and clones the given `RELATIONSHIP` values.
If no `RELATIONSHIP` values are provided, all existing `RELATIONSHIP` values between the given `NODE` values will be cloned."	"apoc.refactor.cloneSubgraph(nodes :: LIST<NODE>, rels = [] :: LIST<RELATIONSHIP>, config = {} :: MAP) :: (input :: INTEGER, output :: NODE, error :: STRING)"
"apoc.refactor.cloneSubgraphFromPaths"	"Clones a sub-graph defined by the given `LIST<PATH>` values.
It is possible to skip any `NODE` properties using the `skipProperties` `LIST<STRING>` via the config `MAP`."	"apoc.refactor.cloneSubgraphFromPaths(paths :: LIST<PATH>, config = {} :: MAP) :: (input :: INTEGER, output :: NODE, error :: STRING)"
"apoc.refactor.collapseNode"	"Collapses the given `NODE` and replaces it with a `RELATIONSHIP` of the given type."	"apoc.refactor.collapseNode(nodes :: ANY, relType :: STRING) :: (input :: INTEGER, output :: RELATIONSHIP, error :: STRING)"
"apoc.refactor.deleteAndReconnect"	"Removes the given `NODE` values from the `PATH` and reconnects the remaining `NODE` values."	"apoc.refactor.deleteAndReconnect(path :: PATH, nodes :: LIST<NODE>, config = {} :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)"
"apoc.refactor.extractNode"	"Expands the given `RELATIONSHIP` VALUES into intermediate `NODE` VALUES.
The intermediate `NODE` values are connected by the given `outType` and `inType`."	"apoc.refactor.extractNode(rels :: ANY, labels :: LIST<STRING>, outType :: STRING, inType :: STRING) :: (input :: INTEGER, output :: NODE, error :: STRING)"
"apoc.refactor.from"	"Redirects the given `RELATIONSHIP` to the given start `NODE`."	"apoc.refactor.from(rel :: RELATIONSHIP, newNode :: NODE) :: (input :: INTEGER, output :: RELATIONSHIP, error :: STRING)"
"apoc.refactor.invert"	"Inverts the direction of the given `RELATIONSHIP`."	"apoc.refactor.invert(rel :: RELATIONSHIP) :: (input :: INTEGER, output :: RELATIONSHIP, error :: STRING)"
"apoc.refactor.mergeNodes"	"Merges the given `LIST<NODE>` onto the first `NODE` in the `LIST<NODE>`.
All `RELATIONSHIP` values are merged onto that `NODE` as well."	"apoc.refactor.mergeNodes(nodes :: LIST<NODE>, config = {} :: MAP) :: (node :: NODE)"
"apoc.refactor.mergeRelationships"	"Merges the given `LIST<RELATIONSHIP>` onto the first `RELATIONSHIP` in the `LIST<RELATIONSHIP>`."	"apoc.refactor.mergeRelationships(rels :: LIST<RELATIONSHIP>, config = {} :: MAP) :: (rel :: RELATIONSHIP)"
"apoc.refactor.normalizeAsBoolean"	"Refactors the given property to a `BOOLEAN`."	"apoc.refactor.normalizeAsBoolean(entity :: ANY, propertyKey :: STRING, trueValues :: LIST<ANY>, falseValues :: LIST<ANY>)"
"apoc.refactor.rename.label"	"Renames the given label from `oldLabel` to `newLabel` for all `NODE` values.
If a `LIST<NODE>` is provided, the renaming is applied to the `NODE` values within this `LIST<NODE>` only."	"apoc.refactor.rename.label(oldLabel :: STRING, newLabel :: STRING, nodes = [] :: LIST<NODE>) :: (batches :: INTEGER, total :: INTEGER, timeTaken :: INTEGER, committedOperations :: INTEGER, failedOperations :: INTEGER, failedBatches :: INTEGER, retries :: INTEGER, errorMessages :: MAP, batch :: MAP, operations :: MAP, constraints :: LIST<STRING>, indexes :: LIST<STRING>)"
"apoc.refactor.rename.nodeProperty"	"Renames the given property from `oldName` to `newName` for all `NODE` values.
If a `LIST<NODE>` is provided, the renaming is applied to the `NODE` values within this `LIST<NODE>` only."	"apoc.refactor.rename.nodeProperty(oldName :: STRING, newName :: STRING, nodes = [] :: LIST<NODE>, config = {} :: MAP) :: (batches :: INTEGER, total :: INTEGER, timeTaken :: INTEGER, committedOperations :: INTEGER, failedOperations :: INTEGER, failedBatches :: INTEGER, retries :: INTEGER, errorMessages :: MAP, batch :: MAP, operations :: MAP, constraints :: LIST<STRING>, indexes :: LIST<STRING>)"
"apoc.refactor.rename.type"	"Renames all `RELATIONSHIP` values with type `oldType` to `newType`.
If a `LIST<RELATIONSHIP>` is provided, the renaming is applied to the `RELATIONSHIP` values within this `LIST<RELATIONSHIP>` only."	"apoc.refactor.rename.type(oldType :: STRING, newType :: STRING, rels = [] :: LIST<RELATIONSHIP>, config = {} :: MAP) :: (batches :: INTEGER, total :: INTEGER, timeTaken :: INTEGER, committedOperations :: INTEGER, failedOperations :: INTEGER, failedBatches :: INTEGER, retries :: INTEGER, errorMessages :: MAP, batch :: MAP, operations :: MAP, constraints :: LIST<STRING>, indexes :: LIST<STRING>)"
"apoc.refactor.rename.typeProperty"	"Renames the given property from `oldName` to `newName` for all `RELATIONSHIP` values.
If a `LIST<RELATIONSHIP>` is provided, the renaming is applied to the `RELATIONSHIP` values within this `LIST<RELATIONSHIP>` only."	"apoc.refactor.rename.typeProperty(oldName :: STRING, newName :: STRING, rels = [] :: LIST<RELATIONSHIP>, config = {} :: MAP) :: (batches :: INTEGER, total :: INTEGER, timeTaken :: INTEGER, committedOperations :: INTEGER, failedOperations :: INTEGER, failedBatches :: INTEGER, retries :: INTEGER, errorMessages :: MAP, batch :: MAP, operations :: MAP, constraints :: LIST<STRING>, indexes :: LIST<STRING>)"
"apoc.refactor.setType"	"Changes the type of the given `RELATIONSHIP`."	"apoc.refactor.setType(rel :: RELATIONSHIP, newType :: STRING) :: (input :: INTEGER, output :: RELATIONSHIP, error :: STRING)"
"apoc.refactor.to"	"Redirects the given `RELATIONSHIP` to the given end `NODE`."	"apoc.refactor.to(rel :: RELATIONSHIP, endNode :: NODE) :: (input :: INTEGER, output :: RELATIONSHIP, error :: STRING)"
"apoc.schema.assert"	"apoc.schema.assert is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.schema.assert(indexes :: MAP, constraints :: MAP, dropExisting = true :: BOOLEAN) :: (label :: ANY, key :: STRING, keys :: LIST<STRING>, unique :: BOOLEAN, action :: STRING)"
"apoc.schema.nodes"	"apoc.schema.nodes is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.schema.nodes(config = {} :: MAP) :: (name :: STRING, label :: ANY, properties :: LIST<STRING>, status :: STRING, type :: STRING, failure :: STRING, populationProgress :: FLOAT, size :: INTEGER, valuesSelectivity :: FLOAT, userDescription :: STRING)"
"apoc.schema.properties.distinct"	"apoc.schema.properties.distinct is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.schema.properties.distinct(label :: STRING, key :: STRING) :: (value :: LIST<ANY>)"
"apoc.schema.properties.distinctCount"	"apoc.schema.properties.distinctCount is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.schema.properties.distinctCount(label =  :: STRING, key =  :: STRING) :: (label :: STRING, key :: STRING, value :: ANY, count :: INTEGER)"
"apoc.schema.relationships"	"apoc.schema.relationships is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.schema.relationships(config = {} :: MAP) :: (name :: STRING, type :: STRING, properties :: LIST<STRING>, status :: STRING, relationshipType :: ANY)"
"apoc.search.multiSearchReduced"	"Returns a reduced representation of the `NODE` values found after a parallel search over multiple indexes.
The reduced `NODE` values representation includes: node id, node labels, and the searched properties."	"apoc.search.multiSearchReduced(labelPropertyMap :: ANY, operator :: STRING, value :: STRING) :: (id :: INTEGER, labels :: LIST<STRING>, values :: MAP)"
"apoc.search.node"	"Returns all the distinct `NODE` values found after a parallel search over multiple indexes."	"apoc.search.node(labelPropertyMap :: ANY, operator :: STRING, value :: STRING) :: (node :: NODE)"
"apoc.search.nodeAll"	"Returns all the `NODE` values found after a parallel search over multiple indexes."	"apoc.search.nodeAll(labelPropertyMap :: ANY, operator :: STRING, value :: STRING) :: (node :: NODE)"
"apoc.search.nodeAllReduced"	"Returns a reduced representation of the `NODE` values found after a parallel search over multiple indexes.
The reduced `NODE` values representation includes: node id, node labels, and the searched properties."	"apoc.search.nodeAllReduced(labelPropertyMap :: ANY, operator :: STRING, value :: ANY) :: (id :: INTEGER, labels :: LIST<STRING>, values :: MAP)"
"apoc.search.nodeReduced"	"Returns a reduced representation of the distinct `NODE` values found after a parallel search over multiple indexes.
The reduced `NODE` values representation includes: node id, node labels, and the searched properties."	"apoc.search.nodeReduced(labelPropertyMap :: ANY, operator :: STRING, value :: STRING) :: (id :: INTEGER, labels :: LIST<STRING>, values :: MAP)"
"apoc.spatial.geocode"	"Returns the geographic location (latitude, longitude, and description) of the given address using a geocoding service (default: OpenStreetMap)."	"apoc.spatial.geocode(location :: STRING, maxResults = 100 :: INTEGER, quotaException = false :: BOOLEAN, config = {} :: MAP) :: (location :: MAP, data :: MAP, latitude :: FLOAT, longitude :: FLOAT, description :: STRING)"
"apoc.spatial.geocodeOnce"	"Returns the geographic location (latitude, longitude, and description) of the given address using a geocoding service (default: OpenStreetMap).
This procedure returns at most one result."	"apoc.spatial.geocodeOnce(location :: STRING, config = {} :: MAP) :: (location :: MAP, data :: MAP, latitude :: FLOAT, longitude :: FLOAT, description :: STRING)"
"apoc.spatial.reverseGeocode"	"Returns a textual address from the given geographic location (latitude, longitude) using a geocoding service (default: OpenStreetMap).
This procedure returns at most one result."	"apoc.spatial.reverseGeocode(latitude :: FLOAT, longitude :: FLOAT, quotaException = false :: BOOLEAN, config = {} :: MAP) :: (location :: MAP, data :: MAP, latitude :: FLOAT, longitude :: FLOAT, description :: STRING)"
"apoc.spatial.sortByDistance"	"Sorts the given collection of `PATH` values by the sum of their distance based on the latitude/longitude values in the `NODE` values."	"apoc.spatial.sortByDistance(paths :: LIST<PATH>) :: (path :: PATH, distance :: FLOAT)"
"apoc.stats.degrees"	"apoc.stats.degrees is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.stats.degrees(relTypes =  :: STRING) :: (type :: STRING, direction :: STRING, total :: INTEGER, p50 :: INTEGER, p75 :: INTEGER, p90 :: INTEGER, p95 :: INTEGER, p99 :: INTEGER, p999 :: INTEGER, max :: INTEGER, min :: INTEGER, mean :: FLOAT)"
"apoc.text.phoneticDelta"	"Returns the US_ENGLISH soundex character difference between the two given `STRING` values."	"apoc.text.phoneticDelta(text1 :: STRING, text2 :: STRING) :: (phonetic1 :: STRING, phonetic2 :: STRING, delta :: INTEGER)"
"apoc.trigger.add"	"apoc.trigger.add is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.add(name :: STRING, statement :: STRING, selector :: MAP, config = {} :: MAP) :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.trigger.drop"	"apoc.trigger.drop is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.drop(databaseName :: STRING, name :: STRING) :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.trigger.dropAll"	"apoc.trigger.dropAll is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.dropAll(databaseName :: STRING) :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.trigger.install"	"apoc.trigger.install is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.install(databaseName :: STRING, name :: STRING, statement :: STRING, selector :: MAP, config = {} :: MAP) :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.trigger.list"	"apoc.trigger.list is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.list() :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.trigger.pause"	"apoc.trigger.pause is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.pause(name :: STRING) :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.trigger.remove"	"apoc.trigger.remove is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.remove(name :: STRING) :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.trigger.removeAll"	"apoc.trigger.removeAll is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.removeAll() :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.trigger.resume"	"apoc.trigger.resume is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.resume(name :: STRING) :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.trigger.show"	"apoc.trigger.show is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.show(databaseName :: STRING) :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.trigger.start"	"apoc.trigger.start is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.start(databaseName :: STRING, name :: STRING) :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.trigger.stop"	"apoc.trigger.stop is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.trigger.stop(databaseName :: STRING, name :: STRING) :: (name :: STRING, query :: STRING, selector :: MAP, params :: MAP, installed :: BOOLEAN, paused :: BOOLEAN)"
"apoc.util.sleep"	"Causes the currently running Cypher to sleep for the given duration of milliseconds (the transaction termination is honored)."	"apoc.util.sleep(duration :: INTEGER)"
"apoc.util.validate"	"If the given predicate is true an exception is thrown."	"apoc.util.validate(predicate :: BOOLEAN, message :: STRING, params :: LIST<ANY>)"
"apoc.warmup.run"	"apoc.warmup.run is unavailable because it is sandboxed and has dependencies outside of the sandbox. Sandboxing is controlled by the dbms.security.procedures.unrestricted setting. Only unrestrict procedures you can trust with access to database internals."	"apoc.warmup.run(loadProperties = false :: BOOLEAN, loadDynamicProperties = false :: BOOLEAN, loadIndexes = false :: BOOLEAN) :: (pageSize :: INTEGER, totalTime :: INTEGER, transactionWasTerminated :: BOOLEAN, nodesPerPage :: INTEGER, nodesTotal :: INTEGER, nodePages :: INTEGER, nodesTime :: INTEGER, relsPerPage :: INTEGER, relsTotal :: INTEGER, relPages :: INTEGER, relsTime :: INTEGER, relGroupsPerPage :: INTEGER, relGroupsTotal :: INTEGER, relGroupPages :: INTEGER, relGroupsTime :: INTEGER, propertiesLoaded :: BOOLEAN, dynamicPropertiesLoaded :: BOOLEAN, propsPerPage :: INTEGER, propRecordsTotal :: INTEGER, propPages :: INTEGER, propsTime :: INTEGER, stringPropsPerPage :: INTEGER, stringPropRecordsTotal :: INTEGER, stringPropPages :: INTEGER, stringPropsTime :: INTEGER, arrayPropsPerPage :: INTEGER, arrayPropRecordsTotal :: INTEGER, arrayPropPages :: INTEGER, arrayPropsTime :: INTEGER, indexesLoaded :: BOOLEAN, indexPages :: INTEGER, indexTime :: INTEGER)"
"apoc.when"	"This procedure will run the read-only `ifQuery` if the conditional has evaluated to true, otherwise the `elseQuery` will run."	"apoc.when(condition :: BOOLEAN, ifQuery :: STRING, elseQuery =  :: STRING, params = {} :: MAP) :: (value :: MAP)"
"db.awaitIndex"	"Wait for an index to come online (for example: CALL db.awaitIndex("MyIndex", 300))."	"db.awaitIndex(indexName :: STRING, timeOutSeconds = 300 :: INTEGER)"
"db.awaitIndexes"	"Wait for all indexes to come online (for example: CALL db.awaitIndexes(300))."	"db.awaitIndexes(timeOutSeconds = 300 :: INTEGER)"
"db.clearQueryCaches"	"Clears all query caches."	"db.clearQueryCaches() :: (value :: STRING)"
"db.create.setNodeVectorProperty"	"Set a vector property on a given node in a more space efficient representation than Cypher's SET."	"db.create.setNodeVectorProperty(node :: NODE, key :: STRING, vector :: ANY)"
"db.create.setRelationshipVectorProperty"	"Set a vector property on a given relationship in a more space efficient representation than Cypher's SET."	"db.create.setRelationshipVectorProperty(relationship :: RELATIONSHIP, key :: STRING, vector :: ANY)"
"db.create.setVectorProperty"	"Set a vector property on a given node in a more space efficient representation than Cypher's SET."	"db.create.setVectorProperty(node :: NODE, key :: STRING, vector :: ANY) :: (node :: NODE)"
"db.createLabel"	"Create a label"	"db.createLabel(newLabel :: STRING)"
"db.createProperty"	"Create a Property"	"db.createProperty(newProperty :: STRING)"
"db.createRelationshipType"	"Create a RelationshipType"	"db.createRelationshipType(newRelationshipType :: STRING)"
"db.index.fulltext.awaitEventuallyConsistentIndexRefresh"	"Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes."	"db.index.fulltext.awaitEventuallyConsistentIndexRefresh()"
"db.index.fulltext.listAvailableAnalyzers"	"List the available analyzers that the full-text indexes can be configured with."	"db.index.fulltext.listAvailableAnalyzers() :: (analyzer :: STRING, description :: STRING, stopwords :: LIST<STRING>)"
"db.index.fulltext.queryNodes"	"Query the given full-text index. Returns the matching nodes and their Lucene query score, ordered by score.
Valid _key: value_ pairs for the `options` map are:

* 'skip' -- to skip the top N results.
* 'limit' -- to limit the number of results returned.
* 'analyzer' -- to use the specified analyzer as a search analyzer for this query.

The `options` map and any of the keys are optional.
An example of the `options` map: `{skip: 30, limit: 10, analyzer: 'whitespace'}`
"	"db.index.fulltext.queryNodes(indexName :: STRING, queryString :: STRING, options = {} :: MAP) :: (node :: NODE, score :: FLOAT)"
"db.index.fulltext.queryRelationships"	"Query the given full-text index. Returns the matching relationships and their Lucene query score, ordered by score.
Valid _key: value_ pairs for the `options` map are:

* 'skip' -- to skip the top N results.
* 'limit' -- to limit the number of results returned.
* 'analyzer' -- to use the specified analyzer as a search analyzer for this query.

The `options` map and any of the keys are optional.
An example of the `options` map: `{skip: 30, limit: 10, analyzer: 'whitespace'}`
"	"db.index.fulltext.queryRelationships(indexName :: STRING, queryString :: STRING, options = {} :: MAP) :: (relationship :: RELATIONSHIP, score :: FLOAT)"
"db.index.vector.createNodeIndex"	"Create a named node vector index for the specified label and property with the given vector dimensionality using either the EUCLIDEAN or COSINE similarity function.
Both similarity functions are case-insensitive.
Use the `db.index.vector.queryNodes` procedure to query the named index.
"	"db.index.vector.createNodeIndex(indexName :: STRING, label :: STRING, propertyKey :: STRING, vectorDimension :: INTEGER, vectorSimilarityFunction :: STRING)"
"db.index.vector.queryNodes"	"Query the given node vector index.
Returns requested number of nearest neighbors to the provided query vector,
and their similarity score to that query vector, based on the configured similarity function for the index.
The similarity score is a value between [0, 1]; where 0 indicates least similar, 1 most similar.
"	"db.index.vector.queryNodes(indexName :: STRING, numberOfNearestNeighbours :: INTEGER, query :: ANY) :: (node :: NODE, score :: FLOAT)"
"db.index.vector.queryRelationships"	"Query the given relationship vector index.
Returns requested number of nearest neighbors to the provided query vector,
and their similarity score to that query vector, based on the configured similarity function for the index.
The similarity score is a value between [0, 1]; where 0 indicates least similar, 1 most similar.
"	"db.index.vector.queryRelationships(indexName :: STRING, numberOfNearestNeighbours :: INTEGER, query :: ANY) :: (relationship :: RELATIONSHIP, score :: FLOAT)"
"db.info"	"Provides information regarding the database."	"db.info() :: (id :: STRING, name :: STRING, creationDate :: STRING)"
"db.labels"	"List all labels attached to nodes within a database according to the user's access rights. The procedure returns empty results if the user is not authorized to view those labels."	"db.labels() :: (label :: STRING)"
"db.ping"	"This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure."	"db.ping() :: (success :: BOOLEAN)"
"db.prepareForReplanning"	"Triggers an index resample and waits for it to complete, and after that clears query caches. After this procedure has finished queries will be planned using the latest database statistics."	"db.prepareForReplanning(timeOutSeconds = 300 :: INTEGER)"
"db.propertyKeys"	"List all property keys in the database."	"db.propertyKeys() :: (propertyKey :: STRING)"
"db.relationshipTypes"	"List all types attached to relationships within a database according to the user's access rights. The procedure returns empty results if the user is not authorized to view those relationship types."	"db.relationshipTypes() :: (relationshipType :: STRING)"
"db.resampleIndex"	"Schedule resampling of an index (for example: CALL db.resampleIndex("MyIndex"))."	"db.resampleIndex(indexName :: STRING)"
"db.resampleOutdatedIndexes"	"Schedule resampling of all outdated indexes."	"db.resampleOutdatedIndexes()"
"db.schema.nodeTypeProperties"	"Show the derived property schema of the nodes in tabular form."	"db.schema.nodeTypeProperties() :: (nodeType :: STRING, nodeLabels :: LIST<STRING>, propertyName :: STRING, propertyTypes :: LIST<STRING>, mandatory :: BOOLEAN)"
"db.schema.relTypeProperties"	"Show the derived property schema of the relationships in tabular form."	"db.schema.relTypeProperties() :: (relType :: STRING, propertyName :: STRING, propertyTypes :: LIST<STRING>, mandatory :: BOOLEAN)"
"db.schema.visualization"	"Visualizes the schema of the data based on available statistics. A new node is returned for each label. The properties represented on the node include: `name` (label name), `indexes` (list of indexes), and `constraints` (list of constraints). A relationship of a given type is returned for all possible combinations of start and end nodes. The properties represented on the relationship include: `name` (type name). Note that this may include additional relationships that do not exist in the data due to the information available in the count store. "	"db.schema.visualization() :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)"
"db.stats.clear"	"Clear collected data of a given data section. Valid sections are 'QUERIES'"	"db.stats.clear(section :: STRING) :: (section :: STRING, success :: BOOLEAN, message :: STRING)"
"db.stats.collect"	"Start data collection of a given data section. Valid sections are 'QUERIES'"	"db.stats.collect(section :: STRING, config = {} :: MAP) :: (section :: STRING, success :: BOOLEAN, message :: STRING)"
"db.stats.retrieve"	"Retrieve statistical data about the current database. Valid sections are 'GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META'"	"db.stats.retrieve(section :: STRING, config = {} :: MAP) :: (section :: STRING, data :: MAP)"
"db.stats.retrieveAllAnonymized"	"Retrieve all available statistical data about the current database, in an anonymized form."	"db.stats.retrieveAllAnonymized(graphToken :: STRING, config = {} :: MAP) :: (section :: STRING, data :: MAP)"
"db.stats.status"	"Retrieve the status of all available collector daemons, for this database."	"db.stats.status() :: (section :: STRING, status :: STRING, data :: MAP)"
"db.stats.stop"	"Stop data collection of a given data section. Valid sections are 'QUERIES'"	"db.stats.stop(section :: STRING) :: (section :: STRING, success :: BOOLEAN, message :: STRING)"
"dbms.cluster.routing.getRoutingTable"	"Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example, an endpoint may serve read queries, write queries, and/or future `getRoutingTable` requests."	"dbms.cluster.routing.getRoutingTable(context :: MAP, database = null :: STRING) :: (ttl :: INTEGER, servers :: LIST<MAP>)"
"dbms.components"	"List DBMS components and their versions."	"dbms.components() :: (name :: STRING, versions :: LIST<STRING>, edition :: STRING)"
"dbms.info"	"Provides information regarding the DBMS."	"dbms.info() :: (id :: STRING, name :: STRING, creationDate :: STRING)"
"dbms.killConnection"	"Kill network connection with the given connection id."	"dbms.killConnection(id :: STRING) :: (connectionId :: STRING, username :: STRING, message :: STRING)"
"dbms.killConnections"	"Kill all network connections with the given connection ids."	"dbms.killConnections(ids :: LIST<STRING>) :: (connectionId :: STRING, username :: STRING, message :: STRING)"
"dbms.listCapabilities"	"List capabilities."	"dbms.listCapabilities() :: (name :: STRING, description :: STRING, value :: ANY)"
"dbms.listConfig"	"List the currently active configuration settings of Neo4j."	"dbms.listConfig(searchString =  :: STRING) :: (name :: STRING, description :: STRING, value :: STRING, dynamic :: BOOLEAN, defaultValue :: STRING, startupValue :: STRING, explicitlySet :: BOOLEAN, validValues :: STRING)"
"dbms.listConnections"	"List all accepted network connections at this instance that are visible to the user."	"dbms.listConnections() :: (connectionId :: STRING, connectTime :: STRING, connector :: STRING, username :: STRING, userAgent :: STRING, serverAddress :: STRING, clientAddress :: STRING)"
"dbms.queryJmx"	"Query JMX management data by domain and name. For instance, use `*:*` to find all JMX beans."	"dbms.queryJmx(query :: STRING) :: (name :: STRING, description :: STRING, attributes :: MAP)"
"dbms.routing.getRoutingTable"	"Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example, an endpoint may serve read queries, write queries, and/or future `getRoutingTable` requests."	"dbms.routing.getRoutingTable(context :: MAP, database = null :: STRING) :: (ttl :: INTEGER, servers :: LIST<MAP>)"
"dbms.showCurrentUser"	"Show the current user."	"dbms.showCurrentUser() :: (username :: STRING, roles :: LIST<STRING>, flags :: LIST<STRING>)"
"dbms.upgrade"	"Upgrade the system database schema if it is not the current schema."	"dbms.upgrade() :: (status :: STRING, upgradeResult :: STRING)"
"dbms.upgradeStatus"	"Report the current status of the system database sub-graph schema."	"dbms.upgradeStatus() :: (status :: STRING, description :: STRING, resolution :: STRING)"
"tx.getMetaData"	"Provides attached transaction metadata."	"tx.getMetaData() :: (metadata :: MAP)"
"tx.setMetaData"	"Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log."